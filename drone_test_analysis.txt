### `drone_test.py` プログラム詳細解説

このドキュメントは `drone_test.py` のプログラム構成、処理の流れ、そして主要なデータ構造について詳細に解説します。

#### 1. プログラムの構成 (Program Structure)

このプログラムは、Telloドローンをリアルタイムで制御し、そのカメラ映像を受信するためのもので、主に以下のコンポーネントで構成されています。

*   **インポート**:
    *   `socket`: TelloドローンとUDP通信を行うための低レベルネットワークライブラリ。
    *   `threading`: 複数の処理（例: コマンド送信、データ受信、映像表示）を並行して実行するためのライブラリ。
    *   `cv2` (OpenCV): ドローンからの映像ストリームの受信、表示、キー入力の受付、映像上へのテキスト描画など、UIと画像処理全般を担当。
    *   `time`: 処理の間に待機時間を入れるため (`time.sleep()`)。
    *   `numpy`: OpenCVが画像を扱う際の基本的なデータ構造（N次元配列）として利用される。

*   **グローバル変数**:
    *   `sock`: ドローンとのコマンド送受信に使われるソケットオブジェクト。
    *   `TELLO_ADDRESS`: ドローンのIPアドレスとポート番号を格納するタプル。
    *   `TELLO_CAMERA_ADDRESS`: ドローンの映像ストリームを受信するためのUDPアドレス。
    *   `cap`: OpenCVの映像キャプチャオブジェクト。
    *   `command_text`, `battery_text`, `time_text`, `status_text`: ドローンの状態や操作内容を画面に表示するために、スレッド間で共有される文字列変数。

*   **関数群**:
    *   **ドローン制御関数 (`takeoff`, `land`, `forward`, etc.)**:
        *   それぞれが特定のTelloコマンド（例: `'takeoff'`, `'forward 40'`)をUDPで送信する単純なラッパー関数。
    *   **バックグラウンド処理関数**:
        *   `udp_receiver()`: ドローンからのレスポンス（バッテリー残量など）を無限ループで受信し続け、対応するグローバル変数を更新する。
        *   `ask()`: 0.5秒ごとにドローンのバッテリーと飛行時間を問い合わせるコマンドを無限ループで送信し続ける。

*   **スレッド**:
    *   `recv_thread`: `udp_receiver`関数を実行するバックグラウンドスレッド。
    *   `ask_thread`: `ask`関数を実行するバックグラウンドスレッド。
    *   これらはデーモンスレッド (`daemon = True`) として設定されており、メインプログラムが終了すると同時に自動的に終了します。

*   **メイン処理ブロック**:
    *   **初期化シーケンス**: プログラム起動時に一度だけ実行される部分。ソケットの作成、スレッドの起動、ドローンのコマンドモード移行、映像ストリーム開始などを行う。
    *   **メインループ (`while True`)**: プログラムの中核。映像の取得、リサイズ、情報描画、画面表示、キー入力の待機と処理を繰り返す。
    *   **終了処理**: メインループを抜けた後に実行される部分。カメラリソースの解放、ウィンドウの破棄、映像ストリームの停止を行う。

#### 2. 処理の流れ (Execution Flow)

プログラムは以下の順序で処理を実行します。

1.  **初期化フェーズ**:
    1.  UDPソケットを作成し、PC側のポート（8889）にバインド（割り当て）する。
    2.  ドローンからのレスポンスを受信する `recv_thread` を起動する。
    3.  ドローンに状態を問い合わせる `ask_thread` を起動する。
    4.  ドローンに `'command'` を送信し、SDKモードに移行させる。
    5.  ドローンに `'streamon'` を送信し、カメラ映像の配信を開始させる。
    6.  OpenCVの `VideoCapture` を使い、指定されたUDPアドレスからの映像ストリームのキャプチャを開始する。

2.  **メインループフェーズ**:
    1.  `cap.read()` でドローンから映像を1フレーム取得する。
    2.  フレームが取得できなければ、ループの先頭に戻る。
    3.  `cv2.resize()` でフレームサイズを半分にし、処理負荷を軽減する。
    4.  `cv2.putText()` を使い、`command_text` や `battery_text` などの現在の状態をフレーム上に描画する。
    5.  `cv2.imshow()` で加工済みのフレームをウィンドウに表示する。
    6.  `cv2.waitKey(1)` で1ミリ秒間キー入力を待つ。
    7.  押されたキーに応じて、対応するドローン制御関数（例: `w`キーなら `forward()`）を呼び出す。同時に `command_text` を更新して、実行した操作を画面に表示させる。
    8.  `ESC`キーが押された場合、`break` でループを抜ける。
    9.  上記 1〜8 を高速で繰り返す。

3.  **終了フェーズ**:
    1.  `cap.release()` でカメラリソースを解放する。
    2.  `cv2.destroyAllWindows()` で表示していたOpenCVのウィンドウをすべて閉じる。
    3.  ドローンに `'streamoff'` を送信し、映像配信を停止させる。
    4.  プログラムが終了する。（デーモンスレッドも同時に終了する）

#### 3. データ構造 (Data Structures)

*   **コマンド/レスポンス (文字列)**:
    *   **送信**: ドローンへのコマンドは、`'takeoff'`, `'forward 40'`, `'battery?'` のような単純な**UTF-8エンコードされた文字列**としてUDPで送信される。
    *   **受信**: ドローンからのレスポンスも同様に文字列で受信される。プログラムは受信した文字列の内容で種類を判別する。
        *   `'ok'`, `'error'`: コマンド成功/失敗のステータス。
        *   数字のみ (例: `'85'`): バッテリー残量。
        *   末尾が 's' (例: `'12s'`): 飛行時間。

*   **ネットワークアドレス (タプル)**:
    *   `TELLO_ADDRESS`: `('192.168.0.11', 8889)` のように、IPアドレス（文字列）とポート番号（整数）を格納したタプル。`socket.sendto()` の宛先として使用される。

*   **映像フレーム (NumPy配列)**:
    *   `frame`: `cap.read()` が返す、映像1フレーム分のデータ。これは **NumPyのN次元配列 (`numpy.ndarray`)** である。
    *   構造は `(高さ, 幅, 色チャネル)` となっており、例えば `(720, 960, 3)` のような形状を持つ。
    *   色チャネルはBGR (Blue, Green, Red) の順で色が格納されている。
    *   OpenCVの関数 (`resize`, `putText`など) は、すべてこのNumPy配列を直接操作する。

*   **状態保持 (グローバル文字列変数)**:
    *   `command_text`, `battery_text`, `time_text`, `status_text`: これらは単純な**文字列型 (`str`)** のグローバル変数。
    *   `udp_receiver`スレッドやメインループがこれらの変数を更新し、`cv2.putText()` がこれを読み取って画面に表示する。スレッド間で情報を共有するためのシンプルな共有メモリとして機能している。
